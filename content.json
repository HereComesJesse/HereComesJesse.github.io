{"pages":[{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://nogfexception.github.io/images/avatar.jpg 网站名称：NOGFEXCEPTION 网站地址：https://nogfexception.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"个人简介 分享很喜欢的**老罗**的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业目前从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.08.01：开通博客 theme 来源：https://github.com/removeif 本站推荐索引 博客主题相关 技术知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: 'bf7e6985b0decf1395cd', clientSecret: 'd992e46567c857fa15b86584d049ccfc46417930', id: '666666', repo: 'issue_database', owner: 'herecomesjesse', admin: \"herecomesjesse\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"}],"posts":[{"title":"Spring Boot自动配置原理","text":"Spring Boot自动配置原理==spring boot框架使用了特定的方式进行了配置，从而使开发人员不再需要定义样板化的配置，是Java程序猿的一大福音。本篇博客结合spring boot底层源码，说明其自动配置的原理。== SpringBoot启动的时候加载主配置类，其中@EnableAutoConfiguration开启了自动配置的功能。下边来详细说说@EnableAutoConfiguration。12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class&lt;?&gt;[] exclude() default {}; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default {};} @Target(ElementType.TYPE) 表示改注解只能用于普通类、接口或枚举上。 @Retention(RetentionPolicy.RUNTIME)注解不仅被保存到class文件中，jvm加载class文件后，仍然保留。 @Documented 由javadoc记录，成为公共API的一部分。 @Inherited 自动继承。 @AutoConfigurationPackage 将启动类所在的package作为自动配置的package。 @Import(AutoConfigurationImportSelector.class) AutoConfigurationImportSelector类中存在一个SelectImports方法 123456789101112131415161718192021222324252627282930313233@Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry (annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } 加载配置类==SpringFactoriesLoader.loadFactoryNames()== 扫描所有Jar包类路径下的： ​ classLoader.getResources(“META-INF/spring.factories“)，遍历得到其url，然后包装成Properties的形式返回。 ==传回上层方法，从properties中获取到EnableAutoConfiguration.class(类)类名对应的值，最终将这些beans交给spring容器。== 每一个这样的xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。 每一个自动配置类，进行自动配置功能以org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration为例（解决乱码问题） 123456789101112131415161718192021222324@Configuration(proxyBeanMethods = false) // 标识该类是一个配置类@EnableConfigurationProperties(ServerProperties.class) // 启用指定类的ConfigurationProperties功能// 配合ConfigurationProperties 功能： 将配置文件中对应的值和ServerProperties绑定起来，并加入到IOC容器中@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) // Spring底层@Conditional，根据不同的条件决定是否生效；判断是否为web应用，如果是则生效@ConditionalOnClass(CharacterEncodingFilter.class) // 判断当前项目中有无该类（SpringMVC中解决乱码的过滤器）@ConditionalOnProperty(prefix = \"server.servlet.encoding\", value = \"enabled\", matchIfMissing = true) // 判断配置文件中书否存在某个配置 server.servlet.encoding = enable 如果不存在也是默认生效public class HttpEncodingAutoConfiguration { // 已经和SpringBoot配置文件映射了 private final Encoding properties; // 自动获取到IOC容器中的properties public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } @Bean // 给容器中添加一个组件，该组件的某些值需要从properties中获取 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE)); return filter; } 所有在配置文件中能配置的属性都是在xxxPropertis类中封装。12@ConfigurationProperties(prefix = \"server\", ignoreUnknownFields = true) // 从配置文件中获取指定的值和bean的属性进行绑定public class ServerProperties { 根据当前不同的条件，决定这个配置类是否生效。一旦生效，配置类就会将IOC容器中添加相应的最贱，属性是从对用的propertie类中获取的，其中的属性又是和配置文件所绑定的。所以，在配置文件中配置后即可生效。 server.servlet.encoding.enable=true server.servlet.encoding.charset=utf-8 server.servlet.force=true #总结​ 1） SpringBoot启动会加载大量的自动配置类。 ​ 2）在项目开发时，看我们所需要的功能有没有SpringBoot默认写好的自动配置类。 ​ 3） 再看这个自动配置类中到底配置了哪些组件，只要存在我们项目所需要的组件，就无须再配置。 ​ 4） 给容器中自动配置类添加组件的时候，会从properties类中自动获取某些属性，我们可以在配置文件中指定这些属性的值。 ​ 5）若不存在，可自己写我们所需要的配置类。==xxxAutoConfiguration自动配置类 + xxxProperties封装配置文件中的相关属性。==","link":"/2020/08/03/Spring%20Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"title":"博客搭建日志","text":"NOGFEXCEPTION搭建日志 2020-08-01 博客初步搭建成功 2020-08-02尝试接入gittalk，未成功 github仓库中未对Category搭建相关配置 github仓库中未对tags搭建相关配置","link":"/2020/08/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97/"}],"tags":[],"categories":[]}